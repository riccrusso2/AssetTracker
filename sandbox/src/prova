// app.js
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import {
  PieChart,
  Pie,
  Cell,
  Tooltip as ReTooltip,
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  LineChart,
  Line,
  Legend,
  AreaChart,
  Area,
} from "recharts";
import {
  RefreshCw,
  Plus,
  TrendingUp,
  TrendingDown,
  PieChart as PieChartIcon,
  BarChart2,
  LineChart as LineChartIcon,
  Target,
  Info,
  Trash2,
  Moon,
  Sun,
} from "lucide-react";
import "./styles.css";

// --- Utility helpers ---
const LS_ASSETS = "pf.assets.v2";
const LS_HISTORY = "pf.history.v2"; // [{t: ISO, v: number}]
const LS_THEME = "pf.theme.v1";

function cryptoRandomId() {
  return Math.random().toString(36).slice(2, 10);
}

function isMaybeISIN(v) {
  return /^[A-Z0-9]{12}$/i.test((v || "").trim());
}

function formatCurrency(n, currency = "EUR") {
  if (n == null || Number.isNaN(n)) return "—";
  try {
    return new Intl.NumberFormat(undefined, {
      style: "currency",
      currency,
      maximumFractionDigits: 2,
    }).format(n);
  } catch {
    return n.toFixed(2);
  }
}

function round2(n) {
  return Math.round((n + Number.EPSILON) * 100) / 100;
}

// Calcoli statistici
function calcCAGR(history) {
  if (history.length < 2) return 0;
  const start = history[0].v;
  const end = history[history.length - 1].v;
  const years =
    (new Date(history[history.length - 1].t) - new Date(history[0].t)) /
    (1000 * 60 * 60 * 24 * 365);
  if (years <= 0 || start <= 0) return 0;
  return Math.pow(end / start, 1 / years) - 1;
}

function calcVolatility(history) {
  if (history.length < 2) return 0;
  const returns = [];
  for (let i = 1; i < history.length; i++) {
    const r = (history[i].v - history[i - 1].v) / history[i - 1].v;
    returns.push(r);
  }
  const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance =
    returns.reduce((a, b) => a + (b - mean) ** 2, 0) / returns.length;
  return Math.sqrt(variance) * Math.sqrt(252); // annualizzato
}

function calcMaxDrawdown(history) {
  let peak = -Infinity;
  let maxDD = 0;
  history.forEach((h) => {
    if (h.v > peak) peak = h.v;
    const dd = (h.v - peak) / peak;
    if (dd < maxDD) maxDD = dd;
  });
  return maxDD;
}

function calcSharpe(history, rf = 0.02) {
  const cagr = calcCAGR(history);
  const vol = calcVolatility(history);
  if (vol === 0) return 0;
  return (cagr - rf) / vol;
}

function calcSortino(history, rf = 0.02) {
  if (history.length < 2) return 0;
  const returns = [];
  for (let i = 1; i < history.length; i++) {
    const r = (history[i].v - history[i - 1].v) / history[i - 1].v;
    returns.push(r);
  }
  const negReturns = returns.filter((r) => r < 0);
  if (negReturns.length === 0) return 0;
  const meanR = returns.reduce((a, b) => a + b, 0) / returns.length;
  const downsideDev =
    Math.sqrt(
      negReturns.reduce((a, b) => a + (b - rf / 252) ** 2, 0) /
        negReturns.length
    ) * Math.sqrt(252);
  return (meanR * 252 - rf) / downsideDev;
}

// --- Component ---
export default function PortfolioDashboard() {
  const [darkMode, setDarkMode] = useState(
    () => localStorage.getItem(LS_THEME) === "dark"
  );
  const [assets, setAssets] = useState(() => {
    const fromLS = localStorage.getItem(LS_ASSETS);
    if (fromLS) return JSON.parse(fromLS);
    return [];
  });
  const [history, setHistory] = useState(() => {
    const fromLS = localStorage.getItem(LS_HISTORY);
    return fromLS ? JSON.parse(fromLS) : [];
  });

  const [form, setForm] = useState({
    name: "",
    identifier: "", // ISIN
    quantity: "",
    costBasis: "",
    targetWeight: "",
  });
  const [loadingIds, setLoadingIds] = useState({});
  const [error, setError] = useState(null);
  const intervalRef = useRef(null);

  // --- Derived stats ---
  const totals = useMemo(() => {
    const totalValue = assets.reduce(
      (acc, a) => acc + (a.lastPrice ? a.lastPrice * (a.quantity || 0) : 0),
      0
    );
    const totalCost = assets.reduce(
      (acc, a) => acc + (a.costBasis ? a.costBasis * (a.quantity || 0) : 0),
      0
    );
    const totalReturn =
      totalCost > 0 ? (totalValue - totalCost) / totalCost : 0;
    return { totalValue, totalCost, totalReturn };
  }, [assets]);

  // Drift dal target
  const driftIndex = useMemo(() => {
    const tv = totals.totalValue || 0;
    if (tv <= 0) return 0;
    return assets.reduce((acc, a) => {
      const val = (a.lastPrice || 0) * (a.quantity || 0);
      const actualW = tv > 0 ? (val / tv) * 100 : 0;
      const diff = Math.abs(actualW - (a.targetWeight || 0));
      return acc + diff;
    }, 0);
  }, [assets, totals.totalValue]);

  // --- Persist state ---
  useEffect(() => {
    localStorage.setItem(LS_ASSETS, JSON.stringify(assets));
  }, [assets]);
  useEffect(() => {
    localStorage.setItem(LS_HISTORY, JSON.stringify(history));
  }, [history]);
  useEffect(() => {
    document.documentElement.classList.toggle("dark", darkMode);
    localStorage.setItem(LS_THEME, darkMode ? "dark" : "light");
  }, [darkMode]);

  // --- Charts data ---
  const barData = useMemo(
    () =>
      assets
        .map((a) => ({
          name: a.name,
          performance:
            a.costBasis && a.lastPrice
              ? round2(((a.lastPrice - a.costBasis) / a.costBasis) * 100)
              : 0,
        }))
        .sort((a, b) => b.performance - a.performance),
    [assets]
  );

  const lineData = useMemo(
    () =>
      history.map((h) => ({
        time: new Date(h.t).toLocaleDateString(),
        value: h.v,
      })),
    [history]
  );

  // Palette colori consistente
  const COLORS = [
    "#2563eb",
    "#10b981",
    "#f59e0b",
    "#ef4444",
    "#8b5cf6",
    "#14b8a6",
    "#f97316",
    "#22c55e",
  ];

  return (
    <div className={`max-w-7xl mx-auto p-4 space-y-6 ${darkMode ? "dark" : ""}`}>
      <header className="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
        <div>
          <h1 className="text-2xl font-bold">
            Dashboard Portafoglio — Monitoraggio & Ribilanciamento
          </h1>
          <p className="text-sm text-gray-500 flex items-center gap-1 mt-1">
            <Info className="w-4 h-4" /> Aggiornamento automatico ogni 15m
          </p>
        </div>
        <div className="flex items-center gap-4">
          <div className="text-right">
            <div className="text-sm text-gray-500">Valore totale</div>
            <div className="text-2xl font-semibold">
              {formatCurrency(totals.totalValue)}
            </div>
            <div
              className={`text-sm ${
                totals.totalReturn >= 0 ? "text-green-600" : "text-red-600"
              }`}
            >
              Rendimento totale: {(totals.totalReturn * 100).toFixed(2)}%
            </div>
          </div>
          <button
            onClick={() => setDarkMode((s) => !s)}
            className="p-2 rounded-full bg-gray-200 dark:bg-gray-700"
          >
            {darkMode ? <Sun className="w-5 h-5" /> : <Moon className="w-5 h-5" />}
          </button>
        </div>
      </header>

      {/* Nuove statistiche */}
      <section className="grid grid-cols-1 md:grid-cols-5 gap-4">
        <StatCard title="CAGR" value={(calcCAGR(history) * 100).toFixed(2) + "%"} />
        <StatCard title="Volatilità" value={(calcVolatility(history) * 100).toFixed(2) + "%"} />
        <StatCard title="Max Drawdown" value={(calcMaxDrawdown(history) * 100).toFixed(2) + "%"} />
        <StatCard title="Sharpe Ratio" value={calcSharpe(history).toFixed(2)} />
        <StatCard title="Sortino Ratio" value={calcSortino(history).toFixed(2)} />
      </section>

      <section className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow">
        <h3 className="font-semibold mb-2 flex items-center gap-2">
          <BarChart2 className="w-5 h-5" /> Performance per asset
        </h3>
        <div className="h-72">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={barData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis unit="%" />
              <ReTooltip />
              <Bar dataKey="performance" name="Performance %">
                {barData.map((entry, index) => (
                  <Cell key={`bar-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>
      </section>

      <section className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow">
        <h3 className="font-semibold mb-2 flex items-center gap-2">
          <LineChartIcon className="w-5 h-5" /> Valore totale nel tempo
        </h3>
        <div className="h-72">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={lineData}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="time" />
              <YAxis />
              <ReTooltip formatter={(v) => formatCurrency(v)} />
              <Legend />
              <Line
                type="monotone"
                dataKey="value"
                name="Valore totale"
                stroke="#2563eb"
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </section>

      <section className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow">
        <h3 className="font-semibold mb-2 flex items-center gap-2">
          <Target className="w-5 h-5" /> Indice di drift
        </h3>
        <p>
          Il portafoglio è sbilanciato di <b>{driftIndex.toFixed(2)}%</b> rispetto ai target.
        </p>
      </section>
    </div>
  );
}

function StatCard({ title, value }) {
  return (
    <div className="bg-white dark:bg-gray-800 p-4 rounded-2xl shadow text-center">
      <h3 className="text-sm text-gray-500 dark:text-gray-400">{title}</h3>
      <div className="text-xl font-semibold">{value}</div>
    </div>
  );
}
